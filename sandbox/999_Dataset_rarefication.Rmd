---
title: "Rarefying a dataset of jump locations"
author: "Nadege Belouard"
date: "2/14/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

Clusters of jumps might be independent, i.e. SLF hitchhiked multiple times to these locations the same year. Alternatively, they might be the result of SLF quickly spreading from a single jump event. Finally, they can be a mix between these two hypotheses. For the rest of the analyses, we will test the two most contrasted hypotheses in parallel in order to test whether results vary. For the first hypothesis (all points are independent introductions), the dataset consists of all jump points. For the second hypothesis (only one introduction in Harrisburg and Winchester), the dataset consists of each "grouped jumps" summarized each by their most central point.

Starting from a list of jumps with lon/lat coordinates, this vignette will produce a rarefied dataset, keeping only one point per cluster of jumps. This point will be the point that is the closest to the centroid of the cluster of jumps. This is done in 2 steps: first we find clusters of points, and then we find the point to keep.

# Load file and packages
```{r load file and packages}
library(sf)
library(here)
library(tibble)
library(tidyr)
library(dplyr)
library(magrittr)
library(ggplot2)


Jumps <- read.csv(file.path(here(), "exported-data", "jumps.csv"), h=T)
dim(Jumps)
head(Jumps)
Jumps %<>% select(bio_year, latitude_rounded, longitude_rounded) 
```


# Find clusters of jumps
This function finds clusters of jumps and attributes them a group number. 

```{r group_jumps function}

group_jumps <- function(Jumps, gap_size = 15) {
  # The function has two parameters: one is the dataset to search, and the second is the distance between points that we want to consider part of the same group, in kilometers.
  
  #We first add columns for a group number and we attribute an ID to each jump.
  Jumps %<>% add_column(Group = NA,
                        ID = seq(1:dim(Jumps)[1]))
  
  #We create a vector with each year we need to look into 
  bio_year = unique(Jumps$bio_year)

  # Transform the table into a sf file and calculate all pairwise distances between points
  jumps <- st_as_sf(x = Jumps, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  # jumps_proj <- st_transform(jumps, crs = 4326)
  pairwise_dist <- st_distance(x = jumps)
  units(pairwise_dist) <- NULL
  pairwise_dist <- as.data.frame(pairwise_dist)
  
  # Create a table with, for each point, a list of all the neighbor points (which we are going to populate with a loop) 
  close_points <- tibble(Point = seq(1:dim(Jumps)[1]),
                         Neighbors = list(NULL))
  
  for (i in 1:dim(pairwise_dist)[1]) { #take each point of the table
    neighbors_i = c()     # Create an empty vector to contain the list of neighbors for this point
    
      for (j in 1:dim(pairwise_dist)[2]) { # go through all the distances
      if (pairwise_dist[i,j] < gap_size * 1000 & pairwise_dist[i,j] != 0) { # if a point is closer than a gap size to the other point, but not the same point
        neighbors_i <- c(neighbors_i, j) # Add it to the vector
        }
      }
    
    if (length(neighbors_i) > 0){ #if this point has neighbors,
    close_points$Neighbors[[i]] <- neighbors_i # Add the vector to a table with the sample at which it is attributed
    } 
  }


  # Merge the lists of neighbor points with common points to obtain groups
  # This is done by iterating the list of neighbors of each point created above
  point_list <- close_points$Point #put the names of all points in a vector
  group_name = 1
  
  while (length(point_list) > 1){ #while there are points in the list of points
    i = point_list[1] # take the first point of the list
    group_i = c(i, close_points$Neighbors[[i]]) # initiate the vector with the neighbors of the point i
    
    for (j in (i+1):length(close_points$Point)) { #consider the next point in the table
      if (is.null(close_points$Neighbors[[j]]) == F & #if the new point considered j has neighbors
          close_points$Point[[j]] %in% close_points$Neighbors[[i]]) { # and if this new point j is in the list of neighbors of i  
        for (k in close_points$Neighbors[[j]]){ #look at the list of neighbors of j
          if (!(k %in% group_i) & k != i){ # if the point in the list of neighbors of j is not in the list of neighbors of i
            group_i <- c(group_i, k) # add the point to the list of neighbors of i
          }
        }
      }
    }
    
    for (c in group_i){ #for each point in this final list
      Jumps <- Jumps %>% mutate(Group = replace(Group, ID == c, group_name)) # find their ID in the table and attribute them the group name
    }
    
    point_list <- point_list[!point_list %in% group_i] # now remove all these neighbor points from the list of points to find another group
    group_name = group_name + 1 # the next group will be called n+1
  }

  if (length(point_list) == 1) { # if there is a last point
    if (is.na(Jumps$Group[[point_list]])){ # and this last point is not in any group so far
    Jumps <- Jumps %>% mutate(Group = replace(Group, ID == point_list, group_name)) #attribute the last group name to the last point
    }
  }
  
return(Jumps)
}
```


Run the function on the dataset. Here we applied a distance of 15 km because it is the distance we used to find these jumps in the first place.

```{r run group_jumps function to define groups}

Jump_groups <- group_jumps(Jumps, gap_size = 15)

#Check how many points are identified per cluster, per year
Jump_groups %>% group_by(bio_year, Group) %>% 
  summarise(Nb = n()) %>% 
  filter(Nb > 1)
```


Check the results on a map (see if it makes sense)

```{r map clusters of jumps}
states <- sf::st_as_sf(maps::map("state", plot = FALSE, fill = TRUE))

ggplot() +
  geom_point(data = Jump_groups,
             aes(x = longitude_rounded, y = latitude_rounded,
                 col = as.factor(Group)), size = 2) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) +
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43)) + 
  theme(legend.position="right")

```


# Rarefy the dataset
This function finds the centroid of each group cluster and keeps the point that is the closest to it.

```{r rarefy_groups}

rarefy_groups <- function(Jump_groups) {

  # Create a dataset with centroids for groups
  Jumps_centroids <- Jump_groups %>% group_by(bio_year, Group) %>% 
    summarise(latitude_rounded = mean(latitude_rounded), longitude_rounded = mean(longitude_rounded)) %>% 
    ungroup()
  
  # Prep a column in Jump_groups to store the distance of each point to the centroid (and find the closest one)
  Jump_groups %>% add_column(DistToCentroid = NA)

  # Find the point closest to that centroid. 
  # Create the shapefile with jumps
  Jumps_proj <- st_as_sf(x = Jump_groups, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  
  # Create the shapefile with centroids
  Centroids_proj <- st_as_sf(x = Jumps_centroids, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  
  # Calculate the distance between jumps and the centroid of their group
  for (j in 1:length(Jump_groups$Group)){ 
    Jumper_group = Jumps_proj$Group[j]
    Jumps_proj$DistToCentroid[j] <- st_distance(x = Jumps_proj[j,], y = Centroids_proj %>% filter(Group == Jumper_group))
  }
  
  # Keep the closest point
  st_geometry(Jumps_proj) <- NULL
  Jumps_unique <- Jumps_proj %>% group_by(Group) %>%
    slice(which.min(DistToCentroid)) %>% ungroup()

return(Jumps_unique)
}


```


Run the function on the dataset. 

```{r run rarify_groups function on all datasets}
Jumps_unique <- rarefy_groups(Jump_groups) %>% add_column(Rarefied = TRUE)
```

Check the result on a map. Rarefied points appear in black. 

```{r map clusters}

ggplot(data = states) +
  geom_sf(data = states, fill = "white") +
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43)) +
  geom_point(data = Jump_groups,
             aes(x = longitude_rounded, y = latitude_rounded, 
                 col = as.factor(Group)), shape = 19, size = 3) +
  geom_point(data = Jumps_unique, aes(x = longitude_rounded, y = latitude_rounded)) +
  labs(x = "Longitude", y = "Latitude")+
  theme(legend.position="right")

```


Save the rarefied dataset
```{r save rarefied dataset}
write.csv(Jumps_unique, file.path(here(), "exported-data", "jumps_rarefied.csv"))
```