---
title: "Making the most of invasion records, the case of the spotted lanternfly, part I: parameters optimization"
author: 
- Nadege Belouard^[Temple University, nadege.belouard@temple.edu]
- Sebastiona De Bona^[Temple University, seba.debona@temple.edu]
- Jocelyn E. Behm^[Temple University, jebehm@temple.edu]
- Matthew R. Helmus^[Temple University, mrhelmus@temple.edu]
date: "1/6/2021"
output:
  pdf_document:
    toc: TRUE
    toc_depth: 2
  html_document:
    toc: TRUE
    toc_depth: 3
params:
  display: FALSE
  run: TRUE
  loadfiles: FALSE
  savefiles: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup for rendering, include = F}
# here we set the images to png, to reduce the size of the output
# we set some global paramters in the yaml to allow us to switch the chunks
# of code on and off when displaying
knitr::opts_chunk$set(dpi = 300, warning = FALSE, message = FALSE, echo = FALSE)

# attaching necessary packages
library(tidyverse)
library(magrittr)
library(sf)
library(spData)
library(maps)
library(DescTools)
library(ggmap)
library(reshape2)
library(geosphere)
library(ggplot2)
library(gridExtra)
library(lycordata)
library(knitr)
```


```{r states names and centroid for global map, message = FALSE, warning = FALSE, echo = params$display}
# extracts a map of the States and recodes state labels to show the two-letter code rather than the full state name.

# obtaining simple feature objects for states and finding centroids for label positioning
states <- sf::st_as_sf(maps::map("state", plot = FALSE, fill = TRUE))
states <- cbind(states, st_coordinates(st_centroid(states)))

# making table key for state 2-letter abbreviations
# the vectors state.abb and state.name contains strings of all
# US states and abbreviations
state_abbr <- tibble(state.name = str_to_lower(state.name), state.abb) %>% 
  left_join(tibble(ID = states$ID), ., by = c(ID = "state.name")) %>% 
  mutate(state.abb = replace_na(state.abb, ""))

# adding 2-letter codes to sf
states$code <- state_abbr$state.abb
```

\newpage

# Aim and setup

This section is designed for the optimization of the parameters leading to the list of jump dispersal. The variation in thresholds and jump list caused by the number of disk portions and gap size is evaluated. The final list of jumps is generated, as well as intermediate files that can be used to refine analyses.


```{r packages and data, message = FALSE, warning = FALSE, echo = params$display}

# loading dataset
load("../packages/lycordata-main/exported_data/tinyslf.rda")
slf_tiny <- tinyslf

# The point in south MD is not legitimate (personal communication), we remove it
slf_tiny <- slf_tiny %>% mutate(index = row.names(slf_tiny))
# slf_tiny %>% filter(state == "MD", latitude < 38.99, slf_established == TRUE)
slf_tiny <- slf_tiny %>% filter(index != 281733)
# BE CAREFUL WHEN THE DATASET IS UPDATED!
```


# 1. Data initialization

## Data reshaping


We reshape the table to summarize the information by rounding the geographical coordinates to cells of 100 m^2 (100 m * 100 m), so that one line represents the detection status at a given location for a given year. The code is borrowed from Seba De Bona's `lycordata` vignette to homogenize our data.

Note: when several surveys indicate that SLF are "present" the same year at the same location, we could be tempted to categorize them in the "established" category. However, the category "present" often refers to dead individuals, although this information is not explicitly available. We use a conservative approach and kept the same categories while summarizing the data.

```{r rounding coordinates, echo = params$display, warnings = FALSE, message = FALSE, eval = params$run}
# specifying the width of the mesh, in km
size_of_grid <- 1

# rounding coordinates and summarizing surveys by location and year
# we round the latitude and longitude to 5 digits to avoid problems of memory limitations
#this is ok because the size of the grid is 0.009 at the smallest
grid_data <- slf_tiny %>%
  mutate(latitude_grid = RoundTo(latitude, multiple = size_of_grid/111),
         longitude_grid = RoundTo(longitude, multiple = size_of_grid/85)) %>%
  mutate(latitude_rounded = round(latitude_grid, 5),
         longitude_rounded = round(longitude_grid, 5)) %>% 
  group_by(bio_year, latitude_rounded, longitude_rounded) %>%
  summarise(slf_present = any(slf_present),
            slf_established = any(slf_established)) %>% 
  ungroup()

knitr::kable(head(grid_data))

```

The table now has `r dim(grid_data)[1]` rows.


## Distances and status calculation

```{r calculate distances to the introduction point, echo = params$display, eval = params$run}

#Coordinates of the introduction site, extracted from Barringer et al. 2015
centroid <- c(-75.675340, 40.415240)

#Compute distances to the introduction point, in km
grid_data <- grid_data %>% 
  mutate(DistToIntro = distm(grid_data[,c(3,2)], centroid, fun=distGeo)/1000)

# Compute a single column with the SLF status at each point: undetected, present, or established
grid_data <- grid_data %>%
  mutate(Status = NA)

for (i in 1:length(grid_data$bio_year)) {
  if (grid_data$slf_established[i]) {
    grid_data$Status[i] = "Established"
  } else if (grid_data$slf_present[i]) {
    grid_data$Status[i] = "Present"
  } else {
    grid_data$Status[i] = "Undetected"
  }
}

# Put levels of Status in correct order for plots
grid_data$Status <- factor(grid_data$Status, levels = c("Undetected", "Present", "Established"))

# Save the grid file = points with their distance to the introduction site
write.csv(grid_data, "../exported-data/grid_data.csv", row.names = F)

# The number of rows must be 58,915 with 2021 preliminary data
dim(grid_data)[1]
```

We first calculate the distance between each survey point and the introduction point (-75.675340, 40.415240, from Barringer et al., 2015). This distance will be the basis of all subsequent analyses. The summary of this distance is (in kilometers):  
`r summary(grid_data$DistToIntro)`
We also create a variable summarizing the status of the survey for each point: SLF `r levels(grid_data$Status)`.


## Space division

We divide the invasion records into sectors to increase the accuracy of subsequent calculations.

```{r function: distinguish sectors, echo = params$display, warnings = FALSE, eval = params$run}

# Determine sectors based on trigonometry
# A full circle is 2*pi
# The sector of each point is determined by atan2(y,x), the angle of the point relative to the horizontal line of the introduction site

attribute_sectors <- function(dataset, nb_sectors = 8, centroid = c(-75.675340, 40.415240), rotation = 1) {
  
  # Calculate theta, the angle between the point and the horizontal line, for each point
  x = NULL
  y = NULL
  # dataset$theta <- NA
  # grid_data <- dataset
  grid_data <- dataset %>% add_column(theta = NA,
                                      sectors = nb_sectors)

  for (i in 1:length(grid_data$longitude_rounded)) {
    x = grid_data$longitude_rounded[i] - centroid[1]
    y = grid_data$latitude_rounded[i] - centroid[2]
    grid_data$theta[i] = base::atan2(y,x) + pi
  }

  # Create a variables for the angle
  angle_sector = 2*pi/nb_sectors
  p = angle_sector/rotation
  # Attribute the right disk portion number
  for (i in 0:(rotation-1)){
    grid_data <- grid_data %>% mutate(thetanew = theta - p*i,
                                      thetanew = ifelse(thetanew < 0, thetanew + 2*pi, thetanew),
                                      sector = ceiling((thetanew)/angle_sector)) %>%
      dplyr::select(-thetanew) %>% 
      rename(!!quo_name(paste("rotation", i+1, sep = "")) := sector)
  }
  
  return(grid_data)
}

```

Here are a few examples of space division for data checking:

```{r run function to attribute sectors, echo = params$display, eval = params$run}
# If sectors modification is needed, we can reload the grid_data file directly
# grid_data <- read.csv("../exported-data/grid_data.csv", h=T)

centroid <- c(-75.675340, 40.415240)

# 8 sectors
grid_data_8S <- attribute_sectors(grid_data, nb_sectors = 8, centroid = centroid, rotation = 10)

# 12 sectors
grid_data_12S <- attribute_sectors(grid_data, nb_sectors = 12, centroid = centroid, rotation = 10)

# 16 sectors
grid_data_16S <- attribute_sectors(grid_data, nb_sectors = 16, centroid = centroid, rotation = 10)

# 20 sectors
grid_data_20S <- attribute_sectors(grid_data, nb_sectors = 20, centroid = centroid, rotation = 10)

# Bind all datasets together
grid_data_allrotations_S8_12_16_20 <- bind_rows(grid_data_8S,
                            grid_data_12S, 
                            grid_data_16S,
                            grid_data_20S)

# Save the file containing all the datasets
write.csv(grid_data_allrotations_S8_12_16_20, "../exported-data/grid_data_4S.csv", row.names = F)
```



We generate maps of the delimitation of the disk portions.

## Maps

```{r transform data for maps}
centroid <- c(long = -75.675340, lat = 40.415240)

#pivot_longer for figures
grid_data_long <- grid_data_allrotations_S8_12_16_20 %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 
```



```{r map of 8-12-16 sectors together, fig.cap = "Maps of the different number of sectors used, with established SLF colored by sector (2014-2020)", fig.height = 6, fig.width = 8, warning = F, echo = params$display}


map_8_12_16_20S <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 5))) +
  geom_point(data = grid_data_long,
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~sectors, ncol = 4) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_8-12-16-20sectors.jpg", map_8_12_16_20S, width = 15, height = 4)


map_8_12_16_20S_all <-  ggplot(data = states) +
  geom_point(data = grid_data_long,
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 5))) +
  geom_point(data = grid_data_long,
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~sectors, ncol = 4) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_8-12-16-20sectors_all.jpg", map_8_12_16_20S_all, width = 15, height = 4)
```


```{r map of 8-12-16 sectors separated with 0 rotation, fig.cap = "Map of surveys with established SLF colored by sector (2014-2020)", fig.height = 6, fig.width = 8, warning = F, echo = params$display}

map_8sectors <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 8 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 4))) +
  geom_point(data = grid_data_long %>% filter(sectors == 8 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_8sectors_rotate0.jpg", map_8sectors, width = 6, height = 6)


map_12sectors <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 12 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 4))) +
  geom_point(data = grid_data_long %>% filter(sectors == 12 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_12sectors_rotate0.jpg", map_12sectors, width = 6, height = 6)


map_16sectors <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 16 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 4))) +
  geom_point(data = grid_data_long %>% filter(sectors == 16 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_16sectors_rotate0.jpg", map_16sectors, width = 6, height = 6)


map_20sectors <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 20 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 5))) +
  geom_point(data = grid_data_long %>% filter(sectors == 20 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_20sectors_rotate0.jpg", map_20sectors, width = 6, height = 6)
```


We generate maps of the delimitation of sectors for each number of disk portions AND for each rotation (10 rotations * 4 numbers of disk portions).


```{r map of each rotation of sectors for each number of sectors, fig.cap = "Map of surveys with established SLF colored by sector (2014-2020)", fig.height = 6, fig.width = 8, warning = F, echo = params$display}

map_8sectors_wrap <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 8 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 2))) +
  geom_point(data = grid_data_long %>% filter(sectors == 8 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~rotation_nb, ncol = 5) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_8sectors.jpg", map_8sectors_wrap, width = 15, height = 6)


map_12sectors_wrap <-  ggplot(data = states) +
  geom_point(data = grid_data_long %>% filter(sectors == 12 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 3))) +
  geom_point(data = grid_data_long %>% filter(sectors == 12 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~rotation_nb, ncol = 5) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_12sectors.jpg", map_12sectors_wrap, width = 15, height = 6)

map_16sectors_wrap <-  ggplot(data = states) +
  geom_point(data = grid_data_long  %>% filter(sectors == 16 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 4))) +
  geom_point(data = grid_data_long %>% filter(sectors == 16 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~rotation_nb, ncol = 5) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_16sectors.jpg", map_16sectors_wrap, width = 15, height = 6)

map_20sectors_wrap <-  ggplot(data = states) +
  geom_point(data = grid_data_long  %>% filter(sectors == 20 & Status == "Established" & bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(sectors_nb)), 
             shape = 19, size = 2, show.legend=F) +
  scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 5))) +
  geom_point(data = grid_data_long %>% filter(sectors == 20 & Status == "Established"),
             aes(x = centroid[1], 
                 y = centroid[2]),
             col = "blue", shape = 4, size = 5) +
  geom_text(data = states, aes(X, Y, label = code), size = 4.5) +
  geom_sf(data = states, alpha = 0) + 
  facet_wrap(~rotation_nb, ncol = 5) +
  coord_sf(xlim = c(-81, -73), ylim = c(38, 42.5), expand = FALSE) +
  labs(x = "Longitude", y = "Latitude", col = "Sectors")

ggsave("../figures/vignette_quadrants/sectors_map/map_20sectors.jpg", map_20sectors_wrap, width = 15, height = 6)


```


\newpage



# 2. Yearly radius of the invasion

Skipped - no optimization required.

\newpage



# 3. Differentiating diffusive spread and jump dispersal

## Exploration of histograms of distances to the introduction site

Skipped - no optimization required.


## Function differentiating diffusive spread and jump dispersal

A custom program searches for each year the distance at which the gap occurs, and returns both the survey before this threshold (the limit of diffusive spread) and a list of surveys found after this threshold (jump events).   
* Note that here, we consider that populations do not go extinct, so that the limit of the diffusive spread cannot be lower in year y than in year y+1. This is because fewer and fewer surveys are conducted near the introduction site over time, leading to the appearance of a false first gap near the introduction site (see Figure 3, surveys are shifted on the right in 2019 and 2020).  
* If a jump event is identified closer than 10 miles to a jump from the previous year, it is removed from the list, as SLF likely spread from the jump of the previous year.
* The function runs independently for each disk portion, generating false-positive and false-negative (see troubleshooting with disk rotation).


```{r program that runs this function for each quadrant and year}

threshold_jump_multiple_num <- function(dataset, 
                                    bio_year = c(2014:2020),
                                    gap_size = 10) {
  
  ##############################################################################################
  ## PHASE 1: IDENTIFY THE THREHOLDS OF DIFFUSIVE SPREAD, AND GET A LIST OF POTENTIAL JUMPS  ###
  ##############################################################################################
  #Initialize variables for the results
  Dist = NULL
  Jumps_alls = NULL
  Jumps_allr = NULL
  rotation = unique(sort(dataset$rotation_nb)) #Look for the number of rotations in the dataset
  sector = unique(sort(dataset$sectors_nb)) #Look for the number of portions in the dataset
  
  for (rot in rotation){
    dataset_rot <- dataset %>% filter(rotation_nb == rot) #Create a dataset for this rotation
    
    for (s in sector){
      dataset_n = NULL
      jumpers_sector = data.frame(DistToIntro = 0)
      for (y in bio_year){
        
        #Select the dataset. We assume that no population is going extinct over the years and cumulate datasets.
        dataset_n <- rbind(dataset_n, dataset_rot %>% filter(sectors_nb == s & bio_year == y & Status == "Established"))
        if (dim(dataset_n)[1] == 0){ #If there is no point in the sector up to that year, go to the next sector
          next
        }
   
        # Initialize values
        i = 1
        distancei = 1
        j = 2
        distancej = 2
      
        # Order the variable by increasing order
        distance_sorted <- sort(dataset_n$DistToIntro) 
    
        # Loop until it finds the threshold or until the variable is finished
        while ( (distancei + gap_size > distancej) & (j <= length(distance_sorted)) ) { 
          distancei = distance_sorted[i]
          distancej = distance_sorted[j]
          i = i+1
          j = j+1
          }
    
        if (distancei + gap_size > distancej) { # there is no jump
          threshold = distance_sorted[i]
          } else { #a jump was found, take the previous iteration
          threshold = distance_sorted[i-1]
          # print(paste0("Jump in ", rot, ", portion ", p, " and year ", y, " after distance ", distancei))
          # We make sure that the gap is not due to an absence of surveys!
          dataset_total <- dataset_rot %>% filter(sectors_nb == s & bio_year %in% c(2014:y) & between(DistToIntro, threshold, threshold+15))
          dim(dataset_total)[1]
          if (dim(dataset_total)[1] == 0) { 
            print(paste0("Error: there is no survey in the gap in rotation ", rot, ", sector ", s, " and year ", y, " after distance ", threshold)) 
            }
          }
        
        
        
        #Find the threshold survey in the initial table (that is not ordered)
        rowNumber = which(grepl(threshold, dataset_n$DistToIntro))
        if (length(rowNumber > 1)) { rowNumber = tail(rowNumber, n = 1)} #If the threshold has been the same for several years, take the last year
    
        #Store results in objects
        threshold_survey = dataset_n[rowNumber,]
        
        # Make sure the threshold is associated to the correct year, even if the threshold is the same as the year before
        threshold_survey$bio_year <- y
        jump_survey = dataset_n %>% filter(DistToIntro > threshold & bio_year == y)
        
         # Add results at each iteration
        Dist = rbind(Dist, threshold_survey)
        jumpers_sector = dplyr::bind_rows(jumpers_sector, jump_survey)
        }
      Jumps_alls = rbind(Jumps_alls, jumpers_sector[-1,])
    }
    
    Jumps_allr = rbind(Jumps_allr, Jumps_alls)
  } 
  
  # Reduce the jump list and the dataset to unique points (without repetitions due to rotations)
  Jumps_all = Jumps_allr %>% dplyr::select(-c(sectors_nb, rotation_nb, sectors)) %>% unique()
  dataset_unique = dataset %>% dplyr::select(-c(sectors_nb, rotation_nb, sectors)) %>% unique()
  
  
  
  ###########################################################################
  ## PHASE 2: KEEP ONLY JUMPS AT LEAST <gap size> AWAY FROM OTHER POINTS  ###
  ###########################################################################
  # Are surveys in the list of jump surveys real new jumps or just diffusion of secondary introductions from the previous year?
  # i.e. are new jumpers less than 10 miles from a previous jump?
  # we run that second part on the whole dataset, not within disk portions, to avoid the occurrence of false-positive)

  dataset_nprev = NULL
  Jumps = NULL

  for (y in bio_year[1:length(bio_year)]){
    jumps_year <- Jumps_all %>% dplyr::filter(bio_year == y)  #select jumps for this year
    dataset_all <- dataset_unique %>% dplyr::filter(bio_year %in% c(bio_year[1]:y) & Status == "Established") #all points up to this year
    doubles <- bind_rows(jumps_year, dataset_all) #aggregate the datasets
    dataset_diffusers <- doubles %>% group_by_all() %>% filter(n() == 1) #remove duplicate points = keep only diffusers
  
    jumps_year <- jumps_year %>% add_column(DistToSLF = NA) #Create a column for the dist to the nearest other point
    
    if (dim(dataset_all)[1] == 0 | dim(jumps_year)[1] == 0){
      next
    } else {
      # Create shapefiles with the two sets of points
      dataset_diffusers_layer <- st_as_sf(x = dataset_diffusers, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
      dataset_diffusers_proj <- st_transform(dataset_diffusers_layer, crs = 4326)
      jumps_year_layer <- st_as_sf(x = jumps_year, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
      jumps_year_proj <- st_transform(jumps_year_layer, crs = 4326)
  
      #Calculate their pairwise distances
      for (jump in 1:length(jumps_year_proj$DistToSLF)){
        pairwise_dist <- st_distance(x = jumps_year_proj[jump,], y = dataset_diffusers_proj)
        jumps_year_proj$DistToSLF[jump] <- min(pairwise_dist)
    }
  
      #Select those at least 10 miles away from the others
      st_geometry(jumps_year_proj) <- NULL
      not_a_jump = jumps_year_proj %>% filter(DistToSLF < gap_size*1000) 
      newjumpers = jumps_year_proj %>% filter(DistToSLF > gap_size*1000)
    }
    
    
    
  #################################################################
  ## PHASE 3: REITERATE PHASE 2 WITH POINTS DISCARDED AS JUMPS  ###
  #################################################################
    # Last precaution: re-iterate the analysis with points that were finally not jumps
    # until the dataset stabilises to a list of real jumps away from any other point
      
    if (dim(newjumpers)[1] != 0){ #if jumpers are identified this year, let's check if they are true
      
      while (dim(not_a_jump)[1] != 0){ # until we don't deny any more jumper
        # Create shapefiles with the two sets of points
        notajump_layer <- st_as_sf(x = not_a_jump, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
        notajump_proj <- st_transform(notajump_layer, crs = 4326)
        newjumpers_layer <- st_as_sf(x = newjumpers, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
        newjumpers_proj <- st_transform(newjumpers_layer, crs = 4326)
    
          #Calculate their pairwise distances
        for (jump in 1:length(newjumpers_proj$DistToSLF)){
          pairwise_dist <- st_distance(x = newjumpers_proj[jump,], y = notajump_proj)
          newjumpers_proj$DistToSLF[jump] <- min(pairwise_dist)
        }
  
        #Select those at least 10 miles away from the others
        st_geometry(newjumpers_proj) <- NULL
        not_a_jump = newjumpers_proj %>% filter(DistToSLF < gap_size*1000)
        newjumpers = newjumpers_proj %>% filter(DistToSLF > gap_size*1000)
      } 
    }
    
    Jumps = bind_rows(Jumps, newjumpers) #add the final list of jumpers for each year
  }

  results <- list("Dist" = Dist, "Jump" = Jumps)
  
  return(results)
} 

``` 


```{r test of the program, eval = FALSE}

# If modification of the jump list is needed, we can reload directly the grid_data_4S file
# grid_data_allrotations_S8_12_16_20 <- read.csv("../exported-data/grid_data_4S.csv", h=T)

#pivot_longer for figures
grid_data_long <- grid_data_allrotations_S8_12_16_20 %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 

threshold_jump_multiple_num(dataset = grid_data_long %>% 
                                      filter(bio_year %in% c(2014:2020) & Status == "Established" & sectors == 20),
                                    bio_year = c(2014:2020),
                                    gap_size = 15)


#Graphical verification
spread_distances <- ggplot(data = grid_data %>% filter(Status == "Established" & portion == 8), aes(x = DistToIntro)) + 
  geom_histogram(aes(fill = Status), 
                 breaks = seq(0,100,5)) +
  xlab("Distance from the introduction site (km)") +
  ylab("Number of survey locations") +
  ggtitle("Histogram of distances to the introduction site")+
  theme(plot.title = element_text(hjust = 0.5, size=12), legend.position = "top")

# BEWARE: this program only works for established pops!
# If we want to consider all individuals, the code must be adapted so that the list of jumpers is established within present + established pops, not only present.
```


## Run the program

Now we need to figure out the best set of parameters to find the accurate number of jumps, i.e. the highest number of jumps detected by the algorithm.
To do so, we run several analysis with extreme sets of parameters to get closer to a plateau in the number of jumps that are found.

```{r run the program, echo = params$display, eval = params$run}

# If modification of the jump list is needed, we can reload directly the grid_data_4S file
# grid_data_allrotations_S8_12_16_20 <- read.csv("./exported-data/grid_data_4S.csv", h = T)

# The parameter that increases most the number of jumps is the number of sectors, so we begin with this parameter and a fixed (high) number of rotations, and look for a plateau.

i = 4
initial_number_rotations = 10
Results_prev = c(-1)
centroid <- c(long = -75.675340, lat = 40.415240)

  slfdata <- attribute_sectors(grid_data, nb_sectors = i, centroid = centroid, rotation = initial_number_rotations)
  slfdata_long <- slfdata %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 
Results <- threshold_jump_multiple_num(slfdata_long, gap_size = 15, bio_year = c(2014:2020))


while (dim(Results$Jump)[1] > Results_prev){
  Results_prev <- dim(Results$Jump)[1]
  j = i
  i = i + 4

  slfdata <- attribute_sectors(grid_data, nb_sectors = i, centroid = centroid, rotation = initial_number_rotations)
  slfdata_long <- slfdata %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 
Results <- threshold_jump_multiple_num(slfdata_long, gap_size = 15, bio_year = c(2014:2020))
}

nb_sectors_recommended = j



# Then, look at the number of rotations needed

r = 5
Results_prev = c(-1)

  slfdata <- attribute_sectors(grid_data, nb_sectors = 20, centroid = centroid, rotation = r)
  slfdata_long <- slfdata %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 
Results <- threshold_jump_multiple_num(slfdata_long, gap_size = 15, bio_year = c(2014:2020))


while (dim(Results$Jump)[1] > Results_prev){
  Results_prev <- dim(Results$Jump)[1]
  k = r
  r = r + 5

  slfdata <- attribute_sectors(grid_data, nb_sectors = i, centroid = centroid, rotation = r)
  slfdata_long <- slfdata %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", values_to = "sectors_nb", names_prefix = "rotation", names_transform = list(rotation_nb = as.integer)) 
Results <- threshold_jump_multiple_num(slfdata_long, gap_size = 15, bio_year = c(2014:2020))
}

nb_rotations_recommended = k


# Confirm the number of sectors with this number of rotations
if (initial_number_rotations < nb_rotations_recommended){
  print("Check the number of sectors again!")
} else {
    print(paste0("You're good to go with ", nb_sectors_recommended, " sectors and ", nb_rotations_recommended, " rotations"))
}

# Run the program
slfdata <- attribute_sectors(grid_data, 
                             nb_sectors = nb_sectors_recommended, 
                             centroid = centroid, 
                             rotation = nb_rotations_recommended)
slfdata_long <- slfdata %>% 
  pivot_longer(cols = starts_with("rotation"), names_to = "rotation_nb", 
               values_to = "sectors_nb", names_prefix = "rotation", 
               names_transform = list(rotation_nb = as.integer)) 
Results <- threshold_jump_multiple_num(slfdata_long, gap_size = 15, bio_year = c(2014:2020))

```


\newpage


# 4. Results 


## Threshold locations found per year (with rotations)

Make a single object for all thresholds and save it.

```{r bind threshold datasets}

# Thresholds <- bind_rows(Results_S8_GS20$Dist %>% add_column(params = "S8GS20"),
#                         Results_S12_GS20$Dist %>% add_column(params = "S12GS20"),
#                         Results_S16_GS20$Dist %>% add_column(params = "S16GS20"),
#                         Results_S20_GS20$Dist %>% add_column(params = "S20GS20"),
#                         
#                         Results_S8_GS15$Dist %>% add_column(params = "DP8GS15"),
#                         Results_S12_GS15$Dist %>% add_column(params = "DP12GS15"),
#                         Results_S16_GS15$Dist %>% add_column(params = "DP16GS15"),
#                         Results_S20_GS15$Dist %>% add_column(params = "DP20GS15"),
#                         
#                         Results_S8_GS10$Dist %>% add_column(params = "S8GS10"),
#                         Results_S12_GS10$Dist %>% add_column(params = "S12GS10"),
#                         Results_S16_GS10$Dist %>% add_column(params = "S16GS10"),
#                         Results_S20_GS10$Dist %>% add_column(params = "S20GS10"))

write.csv(Results$Dist, "./exported-data/thresholds.csv", row.names = F)
```


```{r look at thresholds}

# If modification of the jump list is needed, we can reload directly the grid_data_4S file
# Thresholds <- read.csv("../exported-data/thresholds.csv", h=T)

# Thresholds$params <- factor(Thresholds$params, levels = c("S8GS10", "S12GS10", "S16GS10", "S20GS10",
                                                          # "S8GS15", "S12GS15", "S16GS15", "S20GS15",
                                                          # "S8GS20", "S12GS20", "S16GS20", "S20GS20"))

# Reload the grid_data file if necessary
# grid_data <- read.csv("../exported-data/grid_data_4S.csv", h = T)

#Coordinates of the introduction site, extracted from Barringer et al. 2015
# centroid <- c(-75.675340, 40.415240)
# 
# map_thresholds <- ggplot(data = states) +
#   geom_sf(data = states, fill = "white") + 
#   geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2018), sectors == 8),
#              aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(rotation4)), size = 1, shape = 19) +
#   scale_color_manual(values=c(rep(c("lightblue", "yellow", "green", "pink"), 5))) +
#   geom_point(data = grid_data,
#              aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
#    geom_point(data = Thresholds %>% filter(params == "S8GS15", bio_year == 2018, rotation_nb == 4), 
#              aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
#   geom_text(data = states,
#             aes(X, Y, label = code), size = 4) +
#   labs(x = "Longitude", y = "Latitude")+
#   coord_sf(xlim = c(-79, -74), ylim = c(39, 42), expand = FALSE) +
#   theme(legend.position="top")


```


Maps of thresholds for each parameter sets.

```{r map of threshold points per year per rotation, fig.cap = "Map of SLF jumps", fig.height=6, fig.width=10}
centroid <- c(-75.675340, 40.415240)


map_thresholds <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established"),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Results$Dist, 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  facet_wrap(~bio_year, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) +
  theme(legend.position="top")

ggsave("./figures/vignette_quadrants/map_thresholds.jpg", map_thresholds, width = 15, height = 10)



map_thresholds2016 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2016)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Results$Dist %>% filter(bio_year == 2016), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  # facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-77, -75), ylim = c(40, 41), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_thresholds_2016.jpg", map_thresholds2016 , width = 15, height = 10)


map_thresholds2017 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2017)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Results$Dist %>%  filter(bio_year == 2017), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  # facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-77, -74), ylim = c(39.5, 41), expand = FALSE) +  
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_thresholds_2017.jpg", map_thresholds2017 , width = 15, height = 10)


map_thresholds2018 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2018)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2018), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-79, -74), ylim = c(39, 42), expand = FALSE) +
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_thresholds_2018.jpg", map_thresholds2018 , width = 15, height = 10)



map_thresholds2019 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2019)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2019), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(39, 42), expand = FALSE) +
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_thresholds_2019.jpg", map_thresholds2019 , width = 15, height = 10)



map_thresholds2020 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2020), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_thresholds_2020.jpg", map_thresholds2020 , width = 15, height = 10)

```

The gap size of 16 km is discarded because Harrisburg is not considered a jump. We keep gap sizes of 15 and 10 km.
DP16GS10 is discarded - aberrant thresholds are found near the introduction site due to a lack of data.
DP8GS10 is discarded - aberrant threhsolds are found far away from the invasion front
We keep DP8GS15, DP12GS10 and DP12GS15, DP16GS15.

## Jump locations

Make a single object for all jumps and save it.

```{r save file with jumps for all rotations and datasets}

# Jumps <- bind_rows(Results_S8_GS20$Jump %>% add_column(params = "S8GS20"),
#                         Results_S12_GS20$Jump %>% add_column(params = "S12GS20"),
#                         Results_S16_GS20$Jump %>% add_column(params = "S16GS20"),
#                         Results_S20_GS20$Jump %>% add_column(params = "S20GS20"),
#                         
#                         Results_S8_GS15$Jump %>% add_column(params = "S8GS15"),
#                         Results_S12_GS15$Jump %>% add_column(params = "S12GS15"),
#                         Results_S16_GS15$Jump %>% add_column(params = "S16GS15"),
#                         Results_S20_GS15$Jump %>% add_column(params = "S20GS15"),
#                         
#                         Results_S8_GS10$Jump %>% add_column(params = "S8GS10"),
#                         Results_S12_GS10$Jump %>% add_column(params = "S12GS10"),
#                         Results_S16_GS10$Jump %>% add_column(params = "S16GS10"),
#                         Results_S20_GS10$Jump %>% add_column(params = "S20GS10"))

write.csv(Results$Jump, "./exported-data/jumps.csv", row.names = F)
```


```{r look at jumps}
# Reload Jumps if necessary
Jumps <- read.csv("./exported-data/jumps.csv", h=T)

Jumps %>% group_by(params) %>% summarise(count = n())

Jumps$params <- factor(Jumps$params, levels = c("S8GS10", "S12GS10", "S16GS10", "S20GS10",
                                                "S8GS15", "S12GS15", "S16GS15", "S20GS15",
                                                "S8GS20", "S12GS20", "S16GS20", "S20GS20"))
```


Maps of jumps for each parameter sets.

```{r map of jumps per params per year, fig.cap = "Map of SLF jumps", fig.height=6, fig.width=10}

map_jumps2016 <- ggplot(data = states) +
  geom_point(data = Jumps %>%  filter(bio_year %in% c(2014:2015)),
             aes(x = longitude_rounded, y = latitude_rounded), col = "yellow", shape = 19, size = 2) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2016)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2016), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  geom_point(data = Jumps %>%  filter(bio_year == 2016), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-77, -75), ylim = c(40, 41), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_2016.jpg", map_jumps2016 , width = 15, height = 10)


map_jumps2017 <- ggplot(data = states) +
  geom_point(data = Jumps %>%  filter(bio_year %in% c(2014:2016)),
             aes(x = longitude_rounded, y = latitude_rounded), col = "yellow", shape = 19, size = 2) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2017)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data %>%  filter(bio_year == 2017),
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2017), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  geom_point(data = Jumps %>% filter(bio_year == 2017), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-77, -74), ylim = c(39.5, 41), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_2017.jpg", map_jumps2017 , width = 15, height = 10)


map_jumps2018 <- ggplot(data = states) +
  geom_point(data = Jumps %>%  filter(bio_year %in% c(2014:2017)),
             aes(x = longitude_rounded, y = latitude_rounded), col = "yellow", shape = 19, size = 2) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2018)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
   geom_point(data = Thresholds %>%  filter(bio_year == 2018), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  geom_point(data = Jumps %>%  filter(bio_year == 2018), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-79, -74), ylim = c(39, 42), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_2018.jpg", map_jumps2018 , width = 15, height = 10)



map_jumps2019 <- ggplot(data = states) +
  geom_point(data = Jumps %>%  filter(bio_year %in% c(2014:2018)),
             aes(x = longitude_rounded, y = latitude_rounded), col = "yellow", shape = 19, size = 2) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2019)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Thresholds %>%  filter(bio_year == 2019), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  geom_point(data = Jumps %>%  filter(bio_year == 2019), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-81, -73), ylim = c(39, 42), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_2019.jpg", map_jumps2019 , width = 15, height = 10)


map_jumps2020 <- ggplot(data = states) +
  geom_point(data = Jumps %>%  filter(bio_year %in% c(2014:2019)),
             aes(x = longitude_rounded, y = latitude_rounded), col = "yellow", shape = 19, size = 2) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Thresholds %>%  filter(bio_year == 2020), 
             aes(x = longitude_rounded, y = latitude_rounded), col = "black", shape = 21, size = 2) +
  geom_point(data = Jumps %>%  filter(bio_year == 2020), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_2020.jpg", map_jumps2020 , width = 15, height = 10)

```


```{r map all jumps per params set}

# All jumps one set
map_jumps <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Results$Jump, 
             aes(x = longitude_rounded, y = latitude_rounded, fill = as.factor(bio_year)), shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps.jpg", map_jumps , width = 15, height = 10)




map_jumps <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps, 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  facet_wrap(~params, ncol = 4) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps.jpg", map_jumps , width = 15, height = 10)


map_jumps_DP12GS15 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP12GS15"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP12GS15.jpg", map_jumps_DP12GS15, width = 15, height = 10)


map_jumps_DP16GS15 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP16GS15"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP16GS15.jpg", map_jumps_DP16GS15, width = 15, height = 10)


map_jumps_DP20GS15 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP20GS15"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP20GS15.jpg", map_jumps_DP20GS15, width = 15, height = 10)





map_jumps_DP12GS10 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP12GS10"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP12GS10.jpg", map_jumps_DP12GS10, width = 15, height = 10)


map_jumps_DP16GS10 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP16GS10"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP16GS10.jpg", map_jumps_DP16GS10, width = 15, height = 10)


map_jumps_DP20GS10 <- ggplot(data = states) +
  geom_point(data = grid_data %>% filter(Status == "Established", bio_year %in% c(2014:2020)),
             aes(x = longitude_rounded, y = latitude_rounded), size = 1, shape = 19, col = "grey") +
  geom_point(data = grid_data,
             aes(x = centroid[1], y = centroid[2]), col = "blue", shape = 4, size = 5) +
  geom_point(data = Jumps %>% filter(params == "DP20GS10"), 
             aes(x = longitude_rounded, y = latitude_rounded), fill = "blue", shape = 21, size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="top")

ggsave("../figures/vignette_quadrants/map_jumps_DP20GS10.jpg", map_jumps_DP20GS10, width = 15, height = 10)
```




## Compare scenarios 
Compare the jumps lists for the different parameter sets

```{r compare different scenarios}
Jumps %>% count(params)

#Create unique data to merge to the new table
Jumps_unique <- Jumps %>%  select(-DistToSLF, -params) %>% 
  distinct_at(c("latitude_rounded", "longitude_rounded"), .keep_all = T)

#Pivot the table to get the data from each scenario and join the other info needed
Jump_comp <- Jumps %>%
  filter(params %in% c("S12GS10", "S16GS10", "S20GS10", "S12GS15", "S16GS15", "S20GS15")) %>% 
  pivot_wider(id_cols = c("latitude_rounded", "longitude_rounded"), names_from = "params", values_from = "params") %>% 
  mutate_at(.vars = vars(starts_with("S")), function(x){!is.na(x)}) %>%  
  left_join(., Jumps_unique, by = c("latitude_rounded", "longitude_rounded"))

table(Jump_comp$S20GS10, Jump_comp$S12GS15)
```


## Remove duplicates for outbreaks

Find points with important outbreaks

```{r group_jumps aka function for finding outbreaks i.e. detecting groups of points and attributing them a group number}

group_jumps <- function(Jumps_oneparam, gap_size = 15) {
  
  Jumps_oneparam %<>% add_column(Group = NA,
                                ID = seq(1:length(Jumps_oneparam$DistToIntro)))
                                bio_year = unique(Jumps_oneparam$bio_year)

  Jumps_yearn <- Jumps_oneparam 

  # Calculate all pairwise distances between points
  jumps <- st_as_sf(x = Jumps_yearn, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  jumps_proj <- st_transform(jumps, crs = 4326)
  pairwise_dist <- st_distance(x = jumps_proj)
  units(pairwise_dist) <- NULL
  pairwise_dist <- as.data.frame(pairwise_dist)
  
  # Create a table with, for each point, a list of all the neighbor points (which we are going to populate with a loop) 
  close_points <- tibble(Point = seq(1:length(Jumps_yearn$DistToIntro)), Neighbors = list(NULL))
  
  for (i in 1:dim(pairwise_dist)[1]) { #take each point of the table
    neighbors_i = c()     # Create an empty vector to contain the list of neighbors for this point
    
      for (j in 1:dim(pairwise_dist)[2]) { # go through all the distances
      if (pairwise_dist[i,j] < gap_size * 1000 & pairwise_dist[i,j] != 0) { # if a point is closer than a gap size to the other point, but not the same point
        neighbors_i <- c(neighbors_i, j) # Add it to the vector
        }
      }
    
    if (length(neighbors_i) > 0){ #if this point has neighbors,
    close_points$Neighbors[[i]] <- neighbors_i # Add the vector to a table with the sample at which it is attributed
    } 
  }


  # Merge the lists of neighbor points with common points to obtain groups
  # This is done by iterating the list of neighbors of each point created above
  point_list <- close_points$Point #put the names of all points in a vector
  group_name = 1
  
  while (length(point_list) > 1){ #while there are points in the list of points
    i = point_list[1] # take the first point of the list
    group_i = c(i, close_points$Neighbors[[i]]) # initiate the vector with the neighbors of the point i
    
    for (j in (i+1):length(close_points$Point)) { #consider the next point in the table
      if (is.null(close_points$Neighbors[[j]]) == F & #if the new point considered j has neighbors
          close_points$Point[[j]] %in% close_points$Neighbors[[i]]) { # and if this new point j is in the list of neighbors of i  
        for (k in close_points$Neighbors[[j]]){ #look at the list of neighbors of j
          if (!(k %in% group_i) & k != i){ # if the point in the list of neighbors of j is not in the list of neighbors of i
            group_i <- c(group_i, k) # add the point to the list of neighbors of i
          }
        }
      }
    }
    
    for (c in group_i){ #for each point in this final list
      Jumps_oneparam <- Jumps_oneparam %>% mutate(Group = replace(Group, ID == c, group_name)) # find their ID in the table and attribute them the group name
    }
    
    point_list <- point_list[!point_list %in% group_i] # now remove all these neighbor points from the list of points to find another group
    group_name = group_name + 1 # the next group will be called n+1
  }

  if (length(point_list) == 1) { # if there is a last point
    if (is.na(Jumps_oneparam$Group[[point_list]])){ # and this last point is not in any group so far
    Jumps_oneparam <- Jumps_oneparam %>% mutate(Group = replace(Group, ID == point_list, group_name)) #attribute the last group name to the last point
    }
  }
  
return(Jumps_oneparam)
}
```


```{r run group_jumps function to define groups}

# The function needs to run separately for each set of parameters since the list of jumps is not the same!
Jump_groups <- group_jumps(Results$Jump, gap_size = 15)

# Jumps_groups_S8GS10 <- group_jumps(Jumps %>% filter(params == "S8GS10"), gap_size = 10)
# Jumps_groups_S12GS10 <- group_jumps(Jumps %>% filter(params == "S12GS10"), gap_size = 10)
# Jumps_groups_S16GS10 <- group_jumps(Jumps %>% filter(params == "S16GS10"), gap_size = 10)
# Jumps_groups_S20GS10 <- group_jumps(Jumps %>% filter(params == "S20GS10"), gap_size = 10)
# 
# Jumps_groups_S8GS15 <- group_jumps(Jumps %>% filter(params == "S8GS15"), gap_size = 15)
# Jumps_groups_S12GS15 <- group_jumps(Jumps %>% filter(params == "S12GS15"), gap_size = 15)
# Jumps_groups_S16GS15 <- group_jumps(Jumps %>% filter(params == "S16GS15"), gap_size = 15)
# Jumps_groups_S20GS15 <- group_jumps(Jumps %>% filter(params == "S20GS15"), gap_size = 15)
# 
# Jumps_groups_S8GS20 <- group_jumps(Jumps %>% filter(params == "S8GS20"), gap_size = 20)
# Jumps_groups_S12GS20 <- group_jumps(Jumps %>% filter(params == "S12GS20"), gap_size = 20)
# Jumps_groups_S16GS20 <- group_jumps(Jumps %>% filter(params == "S16GS20"), gap_size = 20)
# Jumps_groups_S20GS20 <- group_jumps(Jumps %>% filter(params == "S20GS20"), gap_size = 20)

#Check on a map!
ggplot(data = states) +
  geom_point(data = Jumps_groups_S8GS20,
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(Group)), 
             size = 2) +
  geom_text(data = states,
            aes(X, Y, label = code), size = 4) +
  labs(x = "Longitude", y = "Latitude")+
  geom_sf(data = states, alpha = 0) + 
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  theme(legend.position="right")

#Check how many points there are per group
Jump_groups_cumul <- Jumps_groups_S8GS10 %>% group_by(bio_year, params, Group) %>% summarise(Nb = n()) %>% arrange(-Nb) %>% filter(Nb > 1)

```




Most jump events occurred in Harrisburg, PA, and Winchester, VA, in 2018. They might be true independent jumps, i.e. SLF hitchhiked multiple times to these locations the same year. Alternatively, they might be the result of SLF quickly spreading from a single jump event. Finally, they can be a mix between these two hypotheses. For the rest of the analyses, we will test the two most contrasted hypotheses in parallel in order to test whether results vary. For the first hypothesis (all points are independent introductions), the dataset consists of all jump points. For the second hypothesis (only one introduction in Harrisburg and Winchester), the dataset consists of each "grouped jumps" summarized each by their most central point.


```{r rarefy_groups function aka generate rarified dataset}

rarefy_groups <- function(Jump_groups) {

  # Create a dataset with centroids for groups
  Jumpers_centroids <- Jump_groups %>% group_by(bio_year, Group) %>% 
    summarise(latitude_rounded = mean(latitude_rounded), longitude_rounded = mean(longitude_rounded)) %>% 
    ungroup()
  
  # Prep a column in Jump_groups to store the distance of each point to the centroid (and find the closest one)
  Jump_groups %>% add_column(DistToCentroid = NA)
  
  # Map centroids to see how they fit in the group
  # ggplot(data = states) +
  #   geom_point(data = Jump_groups,
  #              aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(Group)), 
  #              size = 2) +
  #   geom_point(data = Jumpers_centroids %>% filter(Group %in% Jump_groups_cumul$Group), #here I filtered only groups that had N > 1 point
  #              aes(x = longitude_rounded, y = latitude_rounded)) +
  #   geom_text(data = states,
  #             aes(X, Y, label = code), size = 4) +
  #   labs(x = "Longitude", y = "Latitude")+
  #   geom_sf(data = states, alpha = 0) + 
  #   coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) + 
  #   theme(legend.position="right")
  
  
  ##### Find the point closest to that centroid. 
  # Create the shapefiles with jumpers with unique points
  # Object with all jumps: Jump_groups
  Jumps_layer <- st_as_sf(x = Jump_groups, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  Jumpers_proj <- st_transform(Jumps_layer)
  
  # Object with centroids: Jumpers_centroids
  Centroids_layer <- st_as_sf(x = Jumpers_centroids, coords = c("longitude_rounded", "latitude_rounded"), crs = 4326, remove = F)
  Centroids_proj <- st_transform(Centroids_layer)
  
  # Calculate their distance to the centroid
  for (j in 1:length(Jump_groups$Group)){ 
    Jumper_group = Jumpers_proj$Group[j]
    Jumpers_proj$DistToCentroid[j] <- st_distance(x = Jumpers_proj[j,], y = Centroids_proj %>% filter(Group == Jumper_group))
  }
  
  # Keep the closest point
  st_geometry(Jumpers_proj) <- NULL
  Jumpers_unique <- Jumpers_proj %>% group_by(Group) %>% slice(which.min(DistToCentroid)) %>% ungroup()

return(Jumpers_unique)
}


```


Assemble the datasets to have only one big dataset with all jumpers: different sets of parameters, full, and reduced.

```{r run rarify_groups function on all datasets}

Jumps_unique <- rarefy_groups(Jump_groups) %>% add_column(Rarefied = TRUE)

# Jumps_unique_S8GS10 <- rarefy_groups(Jumps_groups_S8GS10)
# Jumps_unique_S12GS10 <- rarefy_groups(Jumps_groups_S12GS10)
# Jumps_unique_S16GS10 <- rarefy_groups(Jumps_groups_S16GS10)
# Jumps_unique_S20GS10 <- rarefy_groups(Jumps_groups_S20GS10)
# Jumps_unique_S8GS15 <- rarefy_groups(Jumps_groups_S8GS15)
# Jumps_unique_S12GS15 <- rarefy_groups(Jumps_groups_S12GS15)
# Jumps_unique_S16GS15 <- rarefy_groups(Jumps_groups_S16GS15)
# Jumps_unique_S20GS15 <- rarefy_groups(Jumps_groups_S20GS15)
# Jumps_unique_S8GS20 <- rarefy_groups(Jumps_groups_S8GS20)
# Jumps_unique_S12GS20 <- rarefy_groups(Jumps_groups_S12GS20)
# Jumps_unique_S16GS20 <- rarefy_groups(Jumps_groups_S16GS20)
# Jumps_unique_S20GS20 <- rarefy_groups(Jumps_groups_S20GS20)

# Map it
map_rarified <- ggplot(data = states) +
  geom_sf(data = states, fill = "white") +
  coord_sf(xlim = c(-82, -72), ylim = c(38, 43), expand = FALSE) +
  geom_point(data = Jump_groups,
             aes(x = longitude_rounded, y = latitude_rounded, col = as.factor(Group)), shape = 19, size = 3) +
  geom_point(data = Jumps_unique, aes(x = longitude_rounded, y = latitude_rounded)) +
  labs(x = "Longitude", y = "Latitude")+
  theme(legend.position="right")

```

```{r assemble all datasets into one}
#Final datasets are Jumps_groups (full dataset) and Jumps_unique (reduced dataset) 
# Jumps_full_rarefied <- bind_rows(Jumps_groups_S8GS10  %>% add_column(type = "full"), 
#                                 Jumps_groups_S12GS10  %>% add_column(type = "full"), 
#                                 Jumps_groups_S16GS10  %>% add_column(type = "full"), 
#                                 Jumps_groups_S20GS10  %>% add_column(type = "full"),
#                                 Jumps_groups_S8GS15  %>% add_column(type = "full"), 
#                                 Jumps_groups_S12GS15  %>% add_column(type = "full"), 
#                                 Jumps_groups_S16GS15  %>% add_column(type = "full"), 
#                                 Jumps_groups_S20GS15  %>% add_column(type = "full"),
#                                 Jumps_groups_S8GS20  %>% add_column(type = "full"), 
#                                 Jumps_groups_S12GS20  %>% add_column(type = "full"), 
#                                 Jumps_groups_S16GS20  %>% add_column(type = "full"), 
#                                 Jumps_groups_S20GS20  %>% add_column(type = "full"),
#                                 
#                                 Jumps_unique_S8GS10  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S12GS10  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S16GS10  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S20GS10  %>% add_column(type = "rarefied") %>% select(-DistToCentroid),
#                                 Jumps_unique_S8GS15  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S12GS15  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S16GS15  %>% add_column(type = "rarefied") %>% select(-DistToCentroid),
#                                 Jumps_unique_S20GS15  %>% add_column(type = "rarefied") %>% select(-DistToCentroid),
#                                 Jumps_unique_S8GS20  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S12GS20  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S16GS20  %>% add_column(type = "rarefied") %>% select(-DistToCentroid), 
#                                 Jumps_unique_S20GS20  %>% add_column(type = "rarefied") %>% select(-DistToCentroid))


Jumps_unique %<>% select("longitude_rounded", "latitude_rounded", "bio_year", "Rarefied")
Jumps_full_rarefied <- merge(Jump_groups, Jumps_unique, by = c("latitude_rounded", "longitude_rounded", "bio_year"),
                             all = T)

write.csv(Jumps_full_rarefied, "../exported-data/jumps_full_rarefied.csv", row.names = F)

Jumps_full_rarefied %>% group_by(type, params) %>% summarise(count = n())

#Pivot the table to get the data from each scenario and join the other info needed
Jumps_wide <- Jumps_full_rarefied %>%
  pivot_wider(id_cols = c("latitude_rounded", "longitude_rounded"), names_from = c("params", "type"), values_from = c("params")) %>% 
  mutate_at(.vars = vars(starts_with("S")), function(x){!is.na(x)}) 

write.csv(Jumps_wide, "../exported-data/jumps_wide.csv", row.names = F)
```


\newpage

# 5. Conclusion

